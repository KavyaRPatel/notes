[{"doc":"This page has not yet sprouted","title":"This page has not yet sprouted","hpath":"403","content":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","url":"https://kavyarpatel.github.io/notes/notes\\403.html","relUrl":"notes\\403.html"},{"doc":"Root","title":"Root","hpath":"root","content":"# Welcome to Dendron\n\nThis is the root of your dendron vault. If you decide to publish your entire vault, this will be your landing page. You are free to customize any part of this page except the frontmatter on top. \n","url":"https://kavyarpatel.github.io/notes","relUrl":"/"},{"doc":"Ugrp","title":"Ugrp","hpath":"ugrp","content":"## Truck number plate verification: \nThe System consists of  two major components:\n1. A Video  capturing source.  \n2. The application that is developed using MATLAB.\nAssumption: Single entry gate and single lane traffic. \n### Steps: \n\n1. Selection of the required frame.\n2. The selected  image is pre-processed  by passing  it over grayscale filter and edge detection is applied to isolate the region of  interest.\n3. The obtained gray image is then binarized, that is, it is converted to a logical matrix  by  giving the  pixel  values of  1  for white shade and  0 for  black shade.\n4. The  gray  level  plate  images  are enhanced by applying contrast extension and median filtering techniques. \n \n#### Contrast Extension: \nIt sharpens the image. \n#### Median Filtering:\nUsed for removing unwanted noisy regions.\n\n## Gray Scale\nA  gray  scale digital  image is  an  image in  which each  pixel  is quantized exclusively the shades of neutral gray, varying from black at the weakest intensity  to white  at the  strongest intensity.\n\nThe  gray  level  plate  images  are enhanced by applying contrast extension and median filtering techniques . So,  the  contrast differences  between images and the  noises such  as dirty regions  in white  background of the plate can be eliminated.\n\n## Contrast differences: \nThe gray-level histogram  of  an  image is  the  distribution  of the  gray  level values in  an image.  The histogram equalization  is a  popular technique  to  improve  the  appearance  of  a  poor  contrasted image. The process  of equalizing  the histogram  of an  image consists of 4 steps: \n(i) Find the sum of the histogram values. \n(ii)  Normalize  these values  dividing by  the total  number of pixels. \n(iii) Multiply these normalized values by the maximum gray-level value. \n(iv) Map the new gray level values.\n\n## Median Filtering:\nIn  this filtering  method, the  3x3 matrices is  passed around  the image.  The  dimension of  these  matrices can  be adjusted according to the noise level. The process of working is \n(i) one pixel is chosen as centre pixel of the 3x3 matrices \n(ii)  the  surrounding  pixels  are  assigned  as  neighborhood pixels  \n(iii) the  sorting process  are employed  between these nine pixels from smaller to the bigger\n(iv) the fifth element is assigned  as  median  element\n(v)  these  procedures  are implemented to the all pixels in plate image.\n\n## Regionprops: \nRegionprops function  returns  the  smallest  bounding  box  that contains  a character. This method is  used to obtain  the bounding boxes of all characters in the number plate.\n![](/assets/images/2021-10-26-14-31-51.png)\n\n## OCR using Templet Matching: \nFor  recognition  to  occur,  the  current  input  character  is compared to  each template  to find  either an  exact match, or the  template  with  the  closest  representation  of  the  input character. It can capture the best position where the character is by  moving standard  template, thereby  carry out  the exact match.  Moving  template  matching  method  is  based  on  the template  of target  character,  using the  template  of standard character to match the target character from eight directions of up, down, left, right, upper left, lower left, upper right, lower right. ","url":"https://kavyarpatel.github.io/notes/notes\\zBvfNdmboFFBnKDFDpGz3.html","relUrl":"notes\\zBvfNdmboFFBnKDFDpGz3.html"},{"doc":"esd lECTURE","title":"esd lECTURE","hpath":"esd lECTURE","content":"\r\n#include<avr/io.h>\r\n#include<avr/inturrupt.h>\r\n\r\n\r\nint main() {\r\n    DDRC = 1<<3;\r\n    PORTD = 1<<2;\r\n    GICR = (1<<INT0);\r\n    sei ();\r\n    TIMSK=(1<< TOIE 0); \r\n   while(1){}\r\n}\r\n ISR(INT0_vect){\r\n     PORTC ^=(1<<3);\r\n }","url":"https://kavyarpatel.github.io/notes/notes\\DN0zohiNK4amVLkBKzbyK.html","relUrl":"notes\\DN0zohiNK4amVLkBKzbyK.html"},{"doc":"Courses","title":"Courses","hpath":"courses","content":"\n","url":"https://kavyarpatel.github.io/notes/notes\\fLxKsxEHQQi4vueNTUQjY.html","relUrl":"notes\\fLxKsxEHQQi4vueNTUQjY.html"},{"doc":"Sem5","title":"Sem5","hpath":"courses.sem5","content":"\n","url":"https://kavyarpatel.github.io/notes/notes\\4fQhCTr8s3JyXDg6dyvcb.html","relUrl":"notes\\4fQhCTr8s3JyXDg6dyvcb.html"},{"doc":"OS","title":"OS","hpath":"courses.sem5.OS","content":"\n","url":"https://kavyarpatel.github.io/notes/notes\\FvxsPIqYeLAfC0Nxh8Rz8.html","relUrl":"notes\\FvxsPIqYeLAfC0Nxh8Rz8.html"},{"doc":"lecture1","title":"lecture1","hpath":"courses.sem5.OS.lecture1","content":"","url":"https://kavyarpatel.github.io/notes/notes\\LASe3NTtU7QoJZjqUzOBN.html","relUrl":"notes\\LASe3NTtU7QoJZjqUzOBN.html"},{"doc":"ESD","title":"ESD","hpath":"courses.sem5.ESD","content":"\n","url":"https://kavyarpatel.github.io/notes/notes\\Zxd2PBCrhSlQAn5a67hu4.html","relUrl":"notes\\Zxd2PBCrhSlQAn5a67hu4.html"},{"doc":"lecture9","title":"lecture9","hpath":"courses.sem5.ESD.lecture9","content":"\n# Keyboard Interfacing:\n![](/assets/images/2021-10-25-11-36-51.png)\n(4th and 5th point missing)\n\n\n![](/assets/images/2021-10-25-11-41-54.png)\n````c\n#include<avr/io>\n#include<util/delay.h>\n\nvoid delay_ms(unsigned int d)\n{\n    _delay_ms(d);\n}\n\n// complete the code.\n\n````\n\n","url":"https://kavyarpatel.github.io/notes/notes\\IDySwTz37ESFiS6Ty5bN1.html","relUrl":"notes\\IDySwTz37ESFiS6Ty5bN1.html"},{"doc":"lecture8","title":"lecture8","hpath":"courses.sem5.ESD.lecture8","content":"\nCommon Cathod:Logic 0 turns on the segment and dp=0\nCommon Anode: Logic 1 turns on the segment and dp=1\n\n![](/assets/images/2021-10-18-11-28-40.png)\n````c\n#include<avr/io.h>\nint main()\n{\n    DDRA = DDRB = 0xFF; // Common Cathode PORTA output\n    while(1)\n    {\n        PORTA = 0x77; // Display A\n        PORTB.b0 = 1; // Enable pin\n    }\n    return 0;\n}\n````\n![](/assets/images/2021-10-18-11-30-54.png)\n````c\n#include<avr/io.h>\nint main()\n{\n    DDRA=DDRB=0xFF;\n    int array[]={0x90,0x80,0xF8,0x82,0x92,0x99,0xB0,0xA4,0xF9,0xC0};\n    while(1)\n    {\n        for(i=0;i<10;i++>)\n        {\n            PORTB=0x01;\n            PORTA=array[i];\n            delay_ms();\n            \n        }\n        \n    }\n    return 0;\n\n}\n````\n![](/assets/images/2021-10-18-11-48-02.png)\n![](/assets/images/2021-10-18-11-49-41.png)\nPIN 4: RS\nRS=0--> instruction codecommand register\nRS-->0 DAta register\n(missing)\n\n![](/assets/images/2021-10-18-11-59-11.png)\n![](/assets/images/2021-10-18-12-00-40.png)\n![](/assets/images/2021-10-18-12-01-09.png)\n![](/assets/images/2021-10-18-12-01-54.png)\n![](/assets/images/2021-10-18-12-12-16.png)\n\n","url":"https://kavyarpatel.github.io/notes/notes\\cQQyfkWfK7K6yReCWFZSl.html","relUrl":"notes\\cQQyfkWfK7K6yReCWFZSl.html"},{"doc":"lecture4","title":"lecture4","hpath":"courses.sem5.ESD.lecture4","content":"![](/assets/images/2021-09-13-05-46-34.png)\n\nQuestion: Write a C program to generate aa square wave of time period 100uSec on Pin 1 of Port A. \n\nTCNT0=206 \nTTCR= 0x01 \n\n```ruby\n#include<avr/io.h>\n\nvoid timeDelay() {\n    TCNT0 = 206; \n    TCCR0 = 0x01;\n    while((TIFR & 0x1) == 0); \n    TCCR0 = 0; \n    TIFR = 0x1; \n}\n\n\nint main() {\n    DDRA = 0x02;\n    while(1)\n    {\n        PORTA = 0x02;\n        timeDelay();\n        PORTA = 0x00;\n        timeDelay();\n    }\n    return 0;\n}\n```\n\n```ruby\n#include<avr/io.h>\n\nint main() {\n    DDRB = 0x01;\n    DDRC = 0xFF;\n    PORTB = 0x01;\n    while(1) {\n        TCCR0 = 0x06;\n        PORTC = TCNT0;\n    }\n}\n``` \n![](/assets/images/2021-09-13-06-52-57.png)\n```ruby\n#include<avr/io.h>\n\nvoid T0Delay() {\n    TCNT0 = 0; // TCNT0 = 0\n    OCR0 = 75; // OCR0 - TCNT0 = 75\n    TCCR0 = 0x09; // CTC mode and no prescaling\n    while( (TIFR & 0x2) == 0); // CHeck 1st bit\n    TCCR0 = 0; // Stop clock\n    TIFR = 0x2; // Reset\n}\n\nint main() {\n    DDRA = 0x02;\n    while(1) {\n        PORTA = PORTA ^ 0x02;\n        T0Delay();\n    }\n    return 0;\n}\n\n```","url":"https://kavyarpatel.github.io/notes/notes\\Ku9ciQRvAFPbpZ6Wvt6yp.html","relUrl":"notes\\Ku9ciQRvAFPbpZ6Wvt6yp.html"},{"doc":"lecture3","title":"lecture3","hpath":"courses.sem5.ESD.lecture3","content":"\nWhen there is prescaling we multiply time duration with prescaler. Prescaler slows down the clock. \n\nTime delay=(256-MM)*Single clock value. \nMM is the decimal value to load in TCNT0.\n\n","url":"https://kavyarpatel.github.io/notes/notes\\9n3KYZ5XHwaJqaq3Ad0Cv.html","relUrl":"notes\\9n3KYZ5XHwaJqaq3Ad0Cv.html"},{"doc":"lecture1","title":"lecture1","hpath":"courses.sem5.ESD.lecture1","content":"\n","url":"https://kavyarpatel.github.io/notes/notes\\03syEcja5eamRtvcZ5Uc9.html","relUrl":"notes\\03syEcja5eamRtvcZ5Uc9.html"},{"doc":"Changelog","title":"Changelog","hpath":"root.changelog","content":"","url":"https://kavyarpatel.github.io/notes/notes\\changelog.html","relUrl":"notes\\changelog.html"}]
